theory TEE
begin

builtins:  asymmetric-encryption, signing, diffie-hellman,symmetric-encryption,
functions: blind/2, unblind/2
equations: unblind( sign(blind(m,r),k),r ) = sign(m,k)
           
           
        //    unblind( blind(m,r),r ) = m

// ****************** Keys ******************

rule Register_pk:           // Registering a public key
    [ Fr(~private_key) ]
  --[ KeyReg( $A ) ]->
    [ 
      !Get_private_key($A, ~private_key), 
      !Get_public_key($A, pk(~private_key)),
      Out(pk(~private_key))
    ]

rule Reveal_private_key:    // Revealing private key
    [ !Get_private_key(A, private_key) ]
  --[ PrivateKeyRevealed(A) ]->
    [ Out(private_key) ]
    
// rule Generate_DH_key_pair: // Registering a DH key
//     [ Fr(~x) ] 
//     --> 
//     [ !Get_dh_private_key($A, ~x),
//       !Get_dh_public_key($A, 'g'^~x),
//       Out('g'^~x)
//     ]

// ****************** Roles ******************
rule Init_Attestation_DatabPVe:       //meaurements
    [ Fr(SML) ]
  --[ ]->
    [ !Get_expected_SML(SML), Out(~SML) ]

rule Init_VF:
    [ 

      Fr(~DH_sk_VF),
      !Get_public_key($PV, pv_public_key),
      !Get_public_key($Coordinator, coordinator_public_key)
    ]
  --[ Create($VF) ]->
    [ Verifier_0($VF,  private_key_vf, ~DH_sk_VF, $Coordinator, coordinator_public_key) 
    ]

rule Init_PV:
    [ 
      Fr(~DH_sk_PV),
      !Get_private_key($PV, private_key_pv),
      !Get_public_key($Coordinator, coordinator_public_key)
    ]
  --[ Create($PV) ]->
    [ Prover_0( $PV, private_key_pv, ~DH_sk_PV,  $Coordinator, coordinator_public_key)
    ]

rule Init_Coordinator:
    [ 
      !Get_private_key($Coordinator, private_key_coordinator)
    ]
  --[ Create($Coordinator) ]->
    [ Coordinator_0( $Coordinator, private_key_coordinator) ]


// ****************** Secure Channel Used to Register Certificate ******************
rule ChanOut_S:
    [ OutS($A, $B, m) ]
  --[ OutS($A, $B, m) ]->
    [ !Sec($A, $B, m) ]

rule ChanIn_S:
    [ !Sec($A, $B, m) ]
  --[ InS($A, $B, m) ]->
    [ InS($A, $B, m) ]

// ****************** Register ******************
/* 

*/
rule VF_RG_01:
    [
        Verifier_0($VF, private_key_vf, DH_sk_VF, $Coordinator, coordinator_public_key)
    ]
  --[  
        RegisterStarted_VF($VF,$Coordinator,pk(private_key_vf)),
        Step1_VF($VF,$Coordinator,pk(private_key_vf))
    ]->
    [ 
        Verifier_01($VF, private_key_vf, DH_sk_VF, $Coordinator, coordinator_public_key),
        OutS($VF, $Coordinator, <$VF, pk(private_key_vf), 'g'^DH_sk_VF>)
    ]

rule PV_RG_01:
    [ 
        Prover_0($PV, private_key_pv, DH_sk_PV,  $Coordinator, coordinator_public_key)
    ]
  --[ 
        RegisterStarted_PV($PV,$Coordinator,pk(private_key_pv)),
        Step1_PV($PV,$Coordinator,pk(private_key_pv))
    ]->
    [ 
        Prover_01($PV, private_key_pv, DH_sk_PV, $Coordinator, coordinator_public_key),
        OutS($PV, $Coordinator, <$PV, pk(private_key_pv), 'g'^DH_sk_PV>)
    ]

rule CD_RG_01:
    let
        ID_PK_VF = <$VF, vf_public_key>
        ID_PK_PV = <$PV, pv_public_key>
        coordinator_public_key = pk(private_key_coordinator)
        root_cert = <$Coordinator, coordinator_public_key, sign(<$Coordinator, coordinator_public_key>, private_key_coordinator)> // <$ID, PK, sign(<$ID,PK>,SK_CA))>
        vf_cert = <ID_PK_VF, sign(ID_PK_VF,private_key_coordinator)>
        pv_cert = <ID_PK_PV, sign(ID_PK_PV,private_key_coordinator)>
    in
    [     
        Coordinator_0($Coordinator, private_key_coordinator)
        InS($VF, $Coordinator, <ID_PK_VF, 'g'^DH_sk_VF>),
        InS($PV, $Coordinator, <ID_PK_PV, 'g'^DH_sk_PV>),
    ]
  --[ 
        Step2($Coordinator,$PV,$VF,root_cert,vf_cert,pv_cert)
    ]->
    [ 
        OutS($Coordinator,$PV,<pv_cert,root_cert, 'g'^DH_sk_VF>),
        OutS($Coordinator,$VF,<vf_cert,root_cert, 'g'^DH_sk_PV>),
        Coordinator_01($Coordinator, private_key_coordinator, $PV, pv_public_key, $VF, vf_public_key)
    ]

rule VF_RG_02:
    let
        vf_cert = <$VF, vf_public_key, vfCertSignCoordinator>
        root_cert = <$Coordinator, coordinator_public_key, rootCertSignCoordinator>
        k_dh =(DH_pk_PV)^DH_sk_VF
    in
    [   
        InS($Coordinator,$VF,<vf_cert,root_cert,DH_pk_PV>),
        Verifier_01($VF, private_key_vf, DH_sk_VF, $Coordinator, coordinator_public_key)
     ]
    --[ 
        Eq(verify(vfCertSignCoordinator,<$VF,vf_public_key>,coordinator_public_key),true),
        Eq(verify(rootCertSignCoordinator,<$Coordinator,coordinator_public_key>,coordinator_public_key),true),
        Step3_VF($VF,$Coordinator,k_dh,root_cert,vf_cert)
    ]->
    [ 
        Verifier_02($VF,k_dh,vf_cert,root_cert, private_key_vf, DH_sk_VF, $Coordinator, coordinator_public_key)
    ]

rule PV_RG_02:
    let
        pv_cert = <$PV, pv_public_key, pvCertSignCoordinator>
        root_cert = <$Coordinator, coordinator_public_key, rootCertSignCoordinator>
        k_dh =(DH_pk_VF)^DH_sk_PV
    in
    [ 
        InS($Coordinator,$PV,<pv_cert,root_cert,DH_pk_VF>),
        Prover_01($PV, private_key_pv, DH_sk_PV, $Coordinator, coordinator_public_key)
     ]
    --[ 
        Eq(verify(pvCertSignCoordinator,<$PV, pv_public_key>,coordinator_public_key),true),
        Eq(verify(rootCertSignCoordinator,<$Coordinator,coordinator_public_key>,coordinator_public_key),true),
        Step3_PV($PV,$Coordinator,k_dh,root_cert,pv_cert)
     ]->
    [ 
        Prover_02($PV, k_dh,pv_cert,root_cert, private_key_pv, DH_sk_PV, $Coordinator, coordinator_public_key)
    ]


// ****************** Protocol ******************
rule VF_1:
    let
        ct = senc(~nonce,k_dh)
    in
    [ 
        Fr(~nonce),
        Verifier_02(VF, id_VF,k_dh,vf_cert,root_cert, private_key_vf, DH_sk_VF, PV, pv_public_key, Coordinator, coordinator_public_key,)
     ]
  --[ 
        Step4(VF, PV, ~nonce)
     ]->
    [   Out(ct),
        Verifier_03(VF, id_VF,k_dh,vf_cert,root_cert,~nonce, private_key_vf, DH_sk_VF, PV, pv_public_key, Coordinator, coordinator_public_key,)
     ]

rule PV_1:
    let
        nonce = sdec(ct,k_dh)
        msg1 = <report,nonce>
        bm1 = blind(msg1,k_dh)
        msg2 = <id_PV,pv_cert,bm1>
        sig = sign(msg2,private_key_pv)
        flow_1 = <report,sig,msg2>
    in
    [   In(ct),
        Prover_02(PV, id_PV, k_dh,pv_cert,root_cert, private_key_pv, DH_sk_PV, Coordinator, coordinator_public_key, VF, vf_public_key),
        !Get_expected_SML(report)
     ]
    --[ 
        Honest(PV),
        Honest(VF),
        AttestStarted(PV,nonce,report),
        Running(PV,VF,nonce),
        Step5(PV,VF,nonce)
    ]->
    [ 
        Out(flow_1),
        Prover_03(bm1,report,msg1,PV, id_PV, k_dh,pv_cert,root_cert, private_key_pv, DH_sk_PV, Coordinator, coordinator_public_key, VF, vf_public_key)
    ]

rule Coordinator_1:          //attest := 'success'
    let
        msg2 = <id_PV,pv_cert,bm1>
    in
   [    Coordinator_01( Coordinator, id_Coor, private_key_coordinator, PV, pv_public_key, VF, vf_public_key),
        In(<report,sig,msg2>),
        !Get_expected_SML(report)
   ]
  --[ 
        Eq(verify(sig,msg2,pv_public_key),true),
        Commit_report(Coordinator,PV,report),
        Honest(Coordinator),
        Honest(PV),
        Step6(Coordinator,PV)
        // Step6(Coordinator,PV,bm1)
   ]->
  [ 
        Coordinator_02( Coordinator,'success',bm1, id_Coor, private_key_coordinator, PV, pv_public_key, VF, vf_public_key)
   ]

rule Coordinator_deny:       //attest := 'failure'
  let
        msg2 = <id_PV,pv_cert,bm1>
  in
  [ 
        Coordinator_01( Coordinator, id_Coor, private_key_coordinator, PV, pv_public_key, VF, vf_public_key),
        In(<report,sig,msg2>)
   ]
  --[ 
        Eq(verify(sig,msg2,pv_public_key),true)
   ]->
  [     
        Coordinator_02( Coordinator,'failure',bm1, id_Coor, private_key_coordinator, PV, pv_public_key, VF, vf_public_key)
]

rule Coordinator_2:
    let
        btk = sign(bm1,private_key_coordinator)
    in
    [ 
        Coordinator_02( Coordinator,attest,bm1, id_Coor, private_key_coordinator, PV, pv_public_key, VF, vf_public_key)
     ]
    --[ 
        AttestCreated(Coordinator,PV,attest),
        Step7(PV,Coordinator)
        // Step7(PV,Coordinator,btk)
     ]->
    [ 
        Out(<attest,btk>),
        Coordinator_03( Coordinator,attest, id_Coor, private_key_coordinator, PV, pv_public_key, VF, vf_public_key)
     ]

rule PV_2:
    let
        utk = unblind(btk,k_dh)
    in
    [ 
        In(<attest,btk>),
        Prover_03(bm1,report,msg1,PV, id_PV, k_dh,pv_cert,root_cert, private_key_pv, DH_sk_PV, Coordinator, coordinator_public_key, VF, vf_public_key)
     ]
    --[
        Eq(verify(btk,bm1,coordinator_public_key),true),
        Eq(verify(utk,msg1,coordinator_public_key),true),
        Step8(PV,Coordinator,VF,attest),
        NotifiedCompletion(PV, Coordinator, attest),
        Honest(Coordinator)
      ]->
    [ 
        Out(<attest,btk,report>)
     ]

rule VF_2:
    let
        bm1 = blind(<report,nonce>,k_dh)
        utk = unblind(btk,k_dh)
    in
    [ 
        In(<attest,btk,report>),
        Verifier_03(VF, id_VF,k_dh,vf_cert,root_cert,nonce, private_key_vf, DH_sk_VF, PV, pv_public_key, Coordinator, coordinator_public_key),
        !Get_private_key(PV, private_key_prover),
        !Get_private_key(Coordinator, private_key_coordinator)
        

    ]
    --[ 
        Eq(verify(btk,bm1,coordinator_public_key),true),
        Eq(verify(utk,<report,nonce>,coordinator_public_key),true),
        Commit(VF, PV, nonce, attest),
        AttestRecieved(VF, Coordinator, PV, nonce, attest),
        Honest(VF),
        Honest(Coordinator),
        Honest(PV),
        Step9(VF, PV, Coordinator, nonce, attest),
        Secret(private_key_vf),
        Secret(private_key_prover),
        Secret(private_key_coordinator)
     ]->
    []

// ****************** Restrictions ******************

// Actions marked with Eq should equal (used for ensuring signarute matches)
restriction equality:
    "All x y #i. Eq(x,y) @i ==> x = y"

restriction private_key_unique:
    "All x #i #j. KeyReg(x) @#i & KeyReg(x) @#j 
        ==> #i = #j"

// ****************** Security Properties ******************

//Correctness Trace
lemma correctness_trace:
     exists-trace
"
    Ex VF Coordinator PV k_dh nonce vf_public_key pv_public_key id_PV id_VF id_Coor root_cert vf_cert pv_cert
       #a #b #c #d #e #f #g #i #j #k #l #n.
       Step1_VF(VF,Coordinator,vf_public_key) @a &
       Step1_PV(PV,Coordinator,pv_public_key) @a &
       Step2(Coordinator,PV,VF,root_cert,pv_cert,vf_cert) @b &(a < b) &
       Step3_VF(VF,Coordinator,PV,k_dh,root_cert,vf_cert) @c &
       Step3_PV(PV,Coordinator,VF,k_dh,root_cert,pv_cert) @c &(b < c) &
       Step4(VF, PV, nonce) @d & (c < d) &
       Step5(PV,VF,nonce) @e & (d < e) &
       Step6(Coordinator,PV) @f & (e < f) &
       Step7(PV,Coordinator) @g & (f < g) &
       Step8(PV,Coordinator,VF,'success') @i & (g < i) &
       Step9(VF, PV, Coordinator, nonce, 'success') @j & (i < j)&
       Create(id_VF, VF) @k &
       Create(id_PV, PV) @l &
       Create(id_Coor, Coordinator) @n
            & not(Ex id agent #m. Create(id, agent) @m & not(#m = #n) & not(#m = #k) & not(#m = #l) ) 
            & not(Ex A #r. PrivateKeyRevealed(A) @r)
"


end