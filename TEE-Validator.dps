free att.
free sk.
free e.
free R[private].
free K_ab,sk_TEE,sk_Val [private].

fun sign/2.
fun pk/1.
fun true/0.
fun false/0.
fun blind/4.
fun unblind/4.


reduc checksign(sign(x,y),x,pk(y))=true;
      checksign(unblind(sign(blind(x,a,b,c),z),a,b,c),x,pk(z))=true.


(* reduc checksign(sign(x,y),x,pk(y))=true;
      checksign(unblind(sign(blind(x,y),z),y),x,pk(z))=true. *)

let TEE_1(sk_TEE,K_ab,e,R,pk_Val)=
    new nonce1;
    let bm=blind(nonce1,K_ab,R,e) in
    let s=sign(m,sk_TEE) in
    out(att,(m,s))

    in(att,blindsign);
    let unblidnsign=unblind(blindsign,K_ab,R,e) in
    if checksign(unblidnsign,pk_Val)= true

let TEE_2(sk_TEE,K_ab,e,R,pk_Val)= 
    new nonce2;
    let bm=blind(nonce2,K_ab,R,e) in
    let s=sign(bm,sk_TEE) in
    out(att,(bm,s));

    in(att,blindsign);
    let unblidnsign=unblind(blindsign,K_ab,R,e) in
    if checksign(unblidnsign,pk_Val)= true
      

let validator(sk_Val,pk_TEE)=
    in(att,both);
    let(x,y)=both in
    (* x=bm,y=s *)
    if checksign(y,pk_TEE) = true then
      let ms=sign(x,sk_Val) in
      out(att,ms)
  

let P =
  out(att,pk(sk_TEE));
  out(att,pk(sk_Val));
  (
    TEE_1(sk_TEE,K_ab,e,R,pk(sk_Val)) |validator(sk_Val,pk(sk_TEE))
).


let Q =
  out(att,pk(sk_TEE));
  out(att,pk(sk_Val));
  (
    TEE_2(sk_TEE,K_ab,e,R,pk(sk_Val)) |validator(sk_Val,pk(sk_TEE))
).


query trace_equiv(P,Q).
