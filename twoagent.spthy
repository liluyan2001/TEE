/*

Remote attestation Protocol Two-Agent Simple
============================================
Authors: Johannes Wilson
Date:       2023-10-31

Trusted:
    AttAg and VF
Untrusted:
    Target, PV_ch (TrustZone channel) and ch (channel)

   prover        verifier
-----------  ch  ---------
|  Target |------|   VF  |
-----------      ---------
     | PV_ch
-----------
|  AttAg  |
-----------


1:  VF 	-> Target: 		     attest_request(<prover, nonce1>, vf_key.sign(<prover, nonce1>))
2:  Target -> VF:          nonce_challenge(nonce1, nonce2)
                           nonce := <nonce1, nonce2>
3:  VF  -> Target:         nonce_confirmed(nonce, vf_key.sign(nonce))
4:  Target	-> AttAg: 		 start_attestation(nonce)
         				           quote := <nonce, SML>
5:  AttAg -> Target: 		   attestation(quote, att_key.sign(quote))
6:  Target -> Verifier: 	 send_quote(quote, att_key.sign(quote))
7:  VF:                    accept/deny

*/

theory TwoAgent
begin

builtins: asymmetric-encryption, signing

// ****************** Keys ******************

rule Register_pk:           // Registering a public key
    [ Fr(~private_key) ]
  --[ KeyReg( $A ) ]->
    [ 
      !Get_private_key($A, ~private_key), 
      !Get_public_key($A, pk(~private_key)),
      Out(pk(~private_key))
    ]

rule Reveal_private_key:    // Revealing private key
    [ !Get_private_key(A, private_key) ]
  --[ PrivateKeyRevealed(A) ]->
    [ Out(private_key) ]

// ****************** Prover Channel ******************

rule ChanOut_PV [colour=ffffff]:
    [ Out_PV(A,x) ]
    -->
    [ Out(<A,x>) ]

rule ChanIn_PV [colour=ffffff]:
    [ In(<A,x>) ]
    -->
    [ In_PV(A,x) ]


// ****************** Roles ******************

rule Init_Attestation_Database:
    [ Fr(~SML) ]
    -->
    [ !Get_expected_SML(~SML), Out(~SML) ]

rule Init_VF:
    [ 
      Fr(~id), 
      !Get_private_key($VF, private_key_vf),
      !Get_public_key($prover, prover_public_key)
    ]
  --[ Create(~id, $VF) ]->
    [ Verifier_0($VF, ~id, private_key_vf, $prover, prover_public_key) ]

rule Init_Target:
    [ 
      Fr(~id_Target),
      !Get_private_key($prover, private_key_prover),
      !Get_public_key($VF, vf_public_key)
    ]
  --[ Create(~id_Target, $prover) ]->
    [ 
      Target_0($prover, ~id_Target, $VF, vf_public_key)
    ] 

rule Init_AttAg:
    [ 
      Fr(~id_AttAg),
      !Get_private_key($prover, private_key_prover)
    ]
  --[ Create(~id_AttAg, $prover) ]->
    [ 
      AttAg_0($prover, ~id_AttAg, private_key_prover)      
    ]  


// ****************** Protocol ******************

/*
1:  VF 	-> Target: 		attest_request(<prover, nonce1>, vf_key.sign(<prover, nonce1>))
*/
rule VF_01 [colour=#adfaff]:
    let m = <'attest_request', prover, ~nonce> in
    [ 
      Fr(~nonce), // Generate fresh nonce
      Verifier_0(VF, id, private_key_vf, prover, prover_public_key)
    ]
  --[ 
      ProtocolStarted(VF, prover, ~nonce),
      Step1(VF, prover, ~nonce, pk(private_key_vf))
    ]->
    [ 
      Verifier_01( VF, id, private_key_vf, ~nonce, prover, prover_public_key),
      Out( <m, sign(m, private_key_vf)> )
    ]

/*
2:  Target -> VF:          challenge_nonce(nonce1, nonce2)
*/
rule Target_01 [colour=#ff9900]:
    let m = <'attest_request', prover, nonce1> in
    [
      In( <m, sig> ),
      Target_0(prover, id_Target, $VF, vf_public_key),
      Fr(~nonce2) // generate nonce of our own
    ]
  --[ 
      Eq(verify(sig, m, vf_public_key), true),
      Step2($VF, prover, nonce1, ~nonce2, vf_public_key)
    ]->
    [ 
      Out( <'nonce_challenge', <nonce1, ~nonce2>> ),
      Target_01(prover, id_Target, $VF, vf_public_key, nonce1, ~nonce2)
    ]

/*
3:  VF  -> Target:         nonce_confirmed(nonce, vf_key.sign(nonce))
*/
rule VF_1 [colour=#adfaff]:
    let 
        nonce = <nonce1, nonce2>
        m = <'nonce_challenge', nonce>
        r = <'nonce_confirmed', nonce>
    in
    [
      In( m ),
      Verifier_01( VF, id, private_key_vf, nonce1, prover, prover_public_key)
    ]
  --[ 
      NonceConfirmed(VF, prover, nonce), 
      Step3(VF, prover, nonce1, nonce2, pk(private_key_vf)) 
    ]->
    [
      Verifier_1( VF, id, nonce, prover, prover_public_key),
      Out( <r, sign(r, private_key_vf)> )
    ]

/*
4:  Target	-> AttAg: 		start_attestation(nonce)
*/
rule Target_1 [colour=#ff9900]:
    let 
        m = <'nonce_confirmed', <nonce1, nonce2>>
        nonce = <nonce1, nonce2>
    in
    [
      In( <m, sig> ),
      Target_01(prover, id_Target, $VF, vf_public_key, nonce1, nonce2)
    ]
  --[ 
      Eq(verify(sig, m, vf_public_key), true),
      Step4($VF, prover, nonce, vf_public_key)
    ]->
    [ 
      Out_PV( prover, nonce ), // send nonce to attestation agent (insecure channel)
      Target_1(prover, id_Target, $VF, nonce)
    ]

/*
5:  AttAg -> Target: 		attestation(quote, att_key.sign(quote))
*/
rule AttAg_1 [colour=#c90000]:
    let m = <nonce, SML>
    in
    [
      In_PV( prover, nonce ),
      AttAg_0(prover, id_AttAg, private_key_prover),
      !Get_expected_SML(SML)
    ]
  --[ 
      QuoteCreated(prover, nonce, SML),
      AttestStarted(prover, nonce),
      Step5(prover, nonce, SML)
    ]->
    [
      Out_PV( prover, <m, sign(m, private_key_prover)> )
    ]

/*
6:  Target -> Verifier: 	send_quote(quote, att_key.sign(quote))
*/
rule Target_2 [colour=#ff9900]:
    let m = <nonce, SML> in
    [ 
      In_PV( prover, <m, sig> ),
      Target_1(prover, id_Target, VF, nonce)
    ]
  --[ 
      Honest(prover), 
      Honest(VF), 
      Running(prover, VF, nonce), 
      Step6(VF, prover, nonce, SML)
    ]->
    [ Out( <'send_quote', <m, sig>> ) ]

/*
7:  VF:                 accept
*/
rule VF_2 [colour=#adfaff]:
    let m = <nonce, SML>
    in
    [
      Verifier_1( VF, id, nonce, prover, prover_public_key),
      In( <'send_quote', <m, sig>> ), // The incoming message needs to contain the matching nonce
      !Get_private_key(prover, prover_sk),
      !Get_private_key(VF, VF_sk),
      !Get_expected_SML(SML)
    ]
  --[ 
      Eq(verify(sig, m, prover_public_key), true),
      Honest(VF),
      Honest(prover),
      Commit(VF, prover, nonce),
      Commit_SML(VF, prover, nonce, SML),
      Step7(VF, prover, nonce, SML),
      Secret(VF_sk),
      Secret(prover_sk)
    ]->
    []


// ****************** Restrictions ******************

// Actions marked with Eq should equal (used for ensuring signarute matches)
restriction equality:
    "All x y #i. Eq(x,y) @i ==> x = y"

// Once a key has been generated for a prover or verifier, they should not be
// able to replace it by a new one
restriction private_key_unique:
    "All x #i #j. KeyReg(x) @#i & KeyReg(x) @#j 
        ==> #i = #j"

// ****************** Security Properties ******************

/*
==========================
Correctness of protocol
==========================
*/

/*
* Correctness Trace
* 
* We verify for all models that there is a trace where the protocol completes
* where every step of the trace happens exactly in the expected order
*/
lemma correctness_trace:
    exists-trace
    "Ex VF prover nonce1 nonce2 vf_public_key SML id_VF id_Target id_AttAg
        #a #b #c #d #e #f #g #n #o #p.
        Step1(VF, prover, nonce1, vf_public_key) @a &
        Step2(VF, prover, nonce1, nonce2, vf_public_key) @b & (a < b) &
        Step3(VF, prover, nonce1, nonce2, vf_public_key) @c & (b < c) &
        Step4(VF, prover, <nonce1, nonce2>, vf_public_key) @d & (c < d) &
        Step5(prover, <nonce1, nonce2>, SML) @e & (d < e) &
        Step6(VF, prover, <nonce1, nonce2>, SML) @f & (e < f) &
        Step7(VF, prover, <nonce1, nonce2>, SML) @g & (f < g) &
        Create(id_VF, VF) @n &
        Create(id_Target, prover) @o &
        Create(id_AttAg, prover) @p
            & not(Ex id agent #s. Create(id, agent) @s & not(#s = #n) & not(#s = #o) & not(#s = #p)) 
            & not(Ex A #r. PrivateKeyRevealed(A) @r)"

/*
======================
lemmas weaker than L1
======================
*/

// Aliveness
lemma aliveness_verif_attag:
    "All VF prover nonce #i. 
        Commit(VF, prover, nonce) @i 
        ==>  ( Ex nonce2 #j. AttestStarted(prover, nonce2) @j ) 
        | (Ex A #r. PrivateKeyRevealed(A) @r & Honest(A) @i)"

// One-Way Non-Injective Agreement
lemma o_w_non_i_agree_verif_attag:
    "All VF prover nonce #i. 
        Commit(VF, prover, nonce) @i 
        ==>  ( Ex #j. AttestStarted(prover, nonce) @j ) 
        | (Ex A #r. PrivateKeyRevealed(A) @r & Honest(A) @i)"

// One-Way Injective Agreement
lemma o_w_i_agree_verif_attag:
    "All VF prover nonce #i. 
        Commit(VF, prover, nonce) @i 
        ==>  ( Ex #j. AttestStarted(prover, nonce) @j
                & j < i 
                & not (Ex VF2 prover2 #i2. Commit(VF2, prover2, nonce) @i2
                    & not (#i2 = #i)))
        | (Ex A #r. PrivateKeyRevealed(A) @r & Honest(A) @i)"

/*
================================
L1 Freshness of Attestation Data
================================
*/

// One-Way Recent Injective Agreement
lemma o_w_r_i_agree_verif_attag:
    "All VF prover nonce1 nonce2 #i. 
        Commit(VF, prover, <nonce1, nonce2>) @i
        ==>  ( Ex #j #k. AttestStarted(prover, <nonce1, nonce2>) @j
                & ProtocolStarted(VF, prover, nonce1) @k
                & k < j
                & j < i
                & not (Ex VF2 prover2 #i2. Commit(VF2, prover2, <nonce1, nonce2>) @i2
                    & not (#i2 = #i)))
        | (Ex A #r. PrivateKeyRevealed(A) @r & Honest(A) @i)"

/*
===========================
Lemmas weaker than L3
===========================
*/

// Aliveness
lemma aliveness_target_verif:
    "All prover VF nonce #i.  
        Running(prover, VF, nonce) @i 
        ==>  ( Ex prover2 nonce2 #j. NonceConfirmed(VF, prover2, nonce2) @j ) 
        | (Ex A #r. PrivateKeyRevealed(A) @r & Honest(A) @i)"

// Weak Agreement
lemma w_agree_target_verif:
    "All prover VF nonce #i. 
        Running(prover, VF, nonce) @i 
        ==>  ( Ex prover nonce2 #j. NonceConfirmed(VF, prover, nonce2) @j ) 
        | (Ex A #r. PrivateKeyRevealed(A) @r & Honest(A) @i)"

// Non-Injective Agreement
lemma n_i_agree_target_verif:
    "All prover VF nonce #i. 
        Running(prover, VF, nonce) @i 
        ==>  ( Ex #j. NonceConfirmed(VF, prover, nonce) @j ) 
        | (Ex A #r. PrivateKeyRevealed(A) @r & Honest(A) @i)"

/*
===========================
L3 Authenticity of Verifier
===========================
*/

// Injective Agreement
lemma inj_agree_target_verif:
    "All prover VF nonce #i. 
        Running(prover, VF, nonce)  @i 
        ==>  ( Ex #j. NonceConfirmed(VF, prover, nonce) @j
                & j < i 
                & not (Ex prover2 VF2 #i2. Running(prover2, VF2, nonce) @i2
                    & not (#i2 = #i)))
        | (Ex A #r. PrivateKeyRevealed(A) @r & Honest(A) @i)"

/*
===========================
Secrecy
===========================
*/

// L6 Secrecy Attestation Keys
lemma secrecy_key:
    "All x #i.
        Secret(x) @i 
        ==> not (Ex #j. K(x) @j)
        | (Ex A #r. PrivateKeyRevealed(A) @r & Honest(A) @i)"

end

/*
tamarin-prover 1.6.1
==============================================================================
summary of summaries:

analyzed: twoagent.spthy

  correctness_trace (exists-trace): verified (26 steps)
  aliveness_verif_attag (all-traces): verified (9 steps)
  o_w_non_i_agree_verif_attag (all-traces): verified (9 steps)
  o_w_i_agree_verif_attag (all-traces): verified (13 steps)
  o_w_r_i_agree_verif_attag (all-traces): verified (16 steps)
  aliveness_target_verif (all-traces): verified (7 steps)
  w_agree_target_verif (all-traces): verified (7 steps)
  n_i_agree_target_verif (all-traces): verified (10 steps)
  inj_agree_target_verif (all-traces): verified (16 steps)
  secrecy_key (all-traces): verified (14 steps)

==============================================================================
*/
